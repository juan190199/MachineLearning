import numpy as npclass MyDataset:    """    Construct feature matrices    3 of the columns in our dataframe are used to construct the target, note that we still leave game as a variable    and 2 of the columns are combined to one feature    another one is the original player name which we don't need either    In total there are 11 features    """    def __init__(self, data):        self.data = data        self.ordinal_feats = ['rating', 'height', 'weight', 'games', 'victories',                              'ties', 'defeats', 'goals', 'birthday']        self.ordinal_feats = list(set(self.ordinal_feats) & set(data.columns))        self.categorical_feats = ['player', 'club', 'leagueCountry', 'position']        self.categorical_feats = list(set(self.categorical_feats) & set(data.columns))        self.n_ord = len(self.ordinal_feats)        self.n_cat = len(self.categorical_feats)        self.n_onehot = np.sum([len(data.loc[:, feat].unique()) for feat in self.categorical_feats])        self.X_ordinal, self.X_catord, self.targets = self.construct_features()    def construct_features(self):        """        :return: tuple            X_ordinal: array-like of shape (data.shape[0], n_ord)                Design matrix of ordinal features            X_catordinal: array-like of shape (data.shape[0], n_cat)                Design matrix of categorical features converted into ordinal ones            targets: array-like of shape (data.shape[0], )                Target vector with frequency of red cards per game        """        X_ordinal = np.zeros((self.data.shape[0], self.n_ord))        for i, feat in enumerate(self.ordinal_feats):            if feat != 'birthday':                X_ordinal[:, i] = self.data.loc[:, feat]            else:                # birthday -> age                # 1st. of July 2015 (publication date cvs file) is taken as reference date                ref_day = 1                ref_month = 7                ref_year = 2015                bds = np.array(self.data.loc[:, 'birthday'])                for j in range(self.data.shape[0]):                    # this can be done in a more elegant way probably...                    bd = bds[j]                    bd_split = bd.split('.')                    day = int(bd_split[0])                    month = int(bd_split[1])                    year = int(bd_split[2])                    if month < ref_month and day < ref_day:                        X_ordinal[j, i] = ref_year - year - 1                    else:                        X_ordinal[j, i] = ref_year - year        # Categorical features to order        X_catord = np.zeros((self.data.shape[0], self.n_cat))        for i, feat in enumerate(self.categorical_feats):            X_catord[:, i] = self.categorical_to_ordinal(feat)        # Construct the target vector by adding up red and yellow red cards and divide by number of games        targets = np.array((self.data.loc[:, 'redCards'] + self.data.loc[:, 'yellowReds']) / self.data.loc[:, 'games'])        return X_ordinal, X_catord, targets    def categorical_to_ordinal(self, cat_label):        """        Establish order of categorical features        :param cat_label: str            Category name        :return: array-like of shape (data.shape[0], )            Array-like with translation of categorical features to ordinal features            by ordering unique labels of category        """        cat_feats = np.array(self.data.loc[:, cat_label])        unique_labs = np.unique(cat_feats)        labs_to_order = {}        for i in range(unique_labs.shape[0]):            labs_to_order[unique_labs[i]] = i        X = np.zeros(self.data.shape[0])        for i in range(self.data.shape[0]):            X[i] = labs_to_order[cat_feats[i]]        assert np.unique(X).shape == unique_labs.shape        return X    def categorical_to_onehot(self, cat_label):        """        :param cat_label: str            Category name        :return: Array-like of shape (data.shape[0], )            Array-like with with translation of categorical features to one-hot vector of features            by ordering unique labels of category        """        cat_feats = np.array(self.data.loc[:, cat_label])        unique_labs = np.unique(cat_feats)        X = np.zeros((self.data.shape[0], unique_labs.shape[0]))        labs_to_pos = {}        for i in range(unique_labs.shape[0]):            labs_to_pos[unique_labs[i]] = i        for i in range(self.data.shape[0]):            pos = labs_to_pos[cat_feats[i]]            X[i, pos] = 1        return X    """    Construct different feature sets:    - oc: the ordinal and categorical to ordinal features    - on: all ordinal and one-hot representation features    - oc_: the ordinal and categorical to ordinal features, normalized    - onr: ordinal (normalized) + one-hot representations of low dimension    """    def get_X_oc(self):        X_oc = np.zeros((self.data.shape[0], self.n_ord + self.n_cat))        X_oc[:, :self.n_ord] = self.X_ordinal        X_oc[:, self.n_ord:] = self.X_catord        return X_oc    def get_X_on(self):        X_on = np.zeros((self.data.shape[0], self.n_ord + self.n_onehot))        X_on[:, :self.n_ord] = self.X_ordinal        n_0 = self.n_ord        for feat in self.categorical_feats:            X_feat = self.categorical_to_onehot(feat)            X_on[:, n_0:n_0 + X_feat.shape[1]] = X_feat            n_0 += X_feat.shape[1]        return X_on    @staticmethod    def normalize_data(X):        X_norm = np.zeros_like(X)        for j in range(X.shape[1]):            mean = np.mean(X[:, j])            std = np.std(X[:, j])            X_norm[:, j] = X[:, j]        return X_norm    def get_X_oc_(self):        X_oc_ = self.normalize_data(self.get_X_oc())        return X_oc_